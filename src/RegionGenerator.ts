import { Point, float, integer } from "./CommonTypes";
import { RasterizationCell } from "./RasterizationCell";
import { RasterizationGrid } from "./RasterizationGrid";

/**
 * Build cohesive regions from the non-obstacle space. It uses the data
 * from the obstacles rasterization {@link ObstacleRasterizer}.
 *
 * This implementation is strongly inspired from CritterAI class "OpenHeightfieldBuilder".
 *
 * Introduction to Height Fields: http://www.critterai.org/projects/nmgen_study/heightfields.html
 *
 * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html
 */
export class RegionGenerator {
  obstacleRegionBordersCleaner: ObstacleRegionBordersCleaner;
  /**
   * Contains a list of cells that are considered to be flooded and
   * therefore are ready to be processed. This list may contain nulls
   * at certain points in the process. Nulls indicate cells that were
   * initially in the list but have been successfully added to a region.
   * The initial size is arbitrary.
   */
  floodedCells: Array<RasterizationCell | null>;
  /**
   * A predefined stack for use in the flood operation. Its content
   * has no meaning outside the new region flooding operation.
   */
  workingStack: Array<RasterizationCell>;

  constructor() {
    this.obstacleRegionBordersCleaner = new ObstacleRegionBordersCleaner();
    this.floodedCells = new Array<RasterizationCell | null>(1024);
    this.workingStack = new Array<RasterizationCell>(1024);
  }

  //TODO implement the smoothing pass on the distance field?
  /**
   * Groups cells into cohesive regions using an watershed based algorithm.
   *
   * This operation depends on neighbor and distance field information.
   * So {@link RegionGenerator.generateDistanceField} operations must be
   * run before this operation.
   *
   * @param grid A field with cell distance information fully generated.
   * @param obstacleCellPadding a padding in cells to apply around the
   * obstacles.
   */
  generateRegions(grid: RasterizationGrid, obstacleCellPadding: integer) {
    // Watershed Algorithm
    //
    // Reference: http://en.wikipedia.org/wiki/Watershed_%28algorithm%29
    // A good visualization:
    // http://artis.imag.fr/Publications/2003/HDS03/ (PDF)
    //
    // Summary:
    //
    // This algorithm utilizes the cell.distanceToObstacle value, which
    // is generated by the generateDistanceField() operation.
    //
    // Using the watershed analogy, the cells which are furthest from
    // a border (highest distance to border) represent the lowest points
    // in the watershed. A border cell represents the highest possible
    // water level.
    //
    // The main loop iterates, starting at the lowest point in the
    // watershed, then incrementing with each loop until the highest
    // allowed water level is reached. This slowly "floods" the cells
    // starting at the lowest points.
    //
    // During each iteration of the loop, cells that are below the
    // current water level are located and an attempt is made to either
    // add them to exiting regions or create new regions from them.
    //
    // During the region expansion phase, if a newly flooded cell
    // borders on an existing region, it is usually added to the region.
    //
    // Any newly flooded cell that survives the region expansion phase
    // is used as a seed for a new region.
    //
    // At the end of the main loop, a final region expansion is
    // performed which should catch any stray cells that escaped region
    // assignment during the main loop.

    // Represents the minimum distance to an obstacle that is considered
    // traversable. I.e. Can't traverse cells closer than this distance
    // to a border. This provides a way of artificially capping the
    // height to which watershed flooding can occur.
    // I.e. Don't let the algorithm flood all the way to the actual border.
    //
    // We add the minimum border distance to take into account the
    // blurring algorithm which can result in a border cell having a
    // border distance > 0.
    const distanceMin = obstacleCellPadding * 2;

    // TODO: EVAL: Figure out why this iteration limit is needed
    // (todo from the CritterAI sources).
    const expandIterations: integer = 4 + distanceMin * 2;

    // Zero is reserved for the obstacle-region. So initializing to 1.
    let nextRegionID = 1;

    const floodedCells = this.floodedCells;

    // Search until the current distance reaches the minimum allowed
    // distance.
    //
    // Note: This loop will not necessarily complete all region
    // assignments. This is OK since a final region assignment step
    // occurs after the loop iteration is complete.
    for (
      // This value represents the current distance from the border which
      // is to be searched. The search starts at the maximum distance then
      // moves toward zero (toward borders).
      //
      // This number will always be divisible by 2.
      let distance = grid.obstacleDistanceMax() & ~1;
      distance > distanceMin;
      distance = Math.max(distance - 2, 0)
    ) {
      // Find all cells that are at or below the current "water level"
      // and are not already assigned to a region. Add these cells to
      // the flooded cell list for processing.
      floodedCells.length = 0;
      for (let y = 1; y < grid.dimY() - 1; y++) {
        for (let x = 1; x < grid.dimX() - 1; x++) {
          const cell = grid.get(x, y);
          if (
            cell.regionID === RasterizationCell.NULL_REGION_ID &&
            cell.distanceToObstacle >= distance
          ) {
            // The cell is not already assigned a region and is
            // below the current "water level". So the cell can be
            // considered for region assignment.
            floodedCells.push(cell);
          }
        }
      }
      if (nextRegionID > 1) {
        // At least one region has already been created, so first
        // try to  put the newly flooded cells into existing regions.
        if (distance > 0) {
          this.expandRegions(grid, floodedCells, expandIterations);
        } else {
          this.expandRegions(grid, floodedCells, -1);
        }
      }

      // Create new regions for all cells that could not be added to
      // existing regions.
      for (const floodedCell of floodedCells) {
        if (
          !floodedCell ||
          floodedCell.regionID !== RasterizationCell.NULL_REGION_ID
        ) {
          // This cell was assigned to a newly created region
          // during an earlier iteration of this loop.
          // So it can be skipped.
          continue;
        }

        // Fill to slightly more than the current "water level".
        // This improves efficiency of the algorithm.
        // And it is necessary with the conservative expansion to ensure that
        // more than one cell is added initially to a new regions otherwise
        // no cell could be added to it later because of the conservative
        // constraint.
        const fillTo = Math.max(distance - 2, distanceMin + 1, 1);
        if (this.floodNewRegion(grid, floodedCell, fillTo, nextRegionID)) {
          nextRegionID++;
        }
      }
    }

    // Find all cells that haven't been assigned regions by the main loop
    // (up to the minimum distance).
    floodedCells.length = 0;
    for (let y = 1; y < grid.dimY() - 1; y++) {
      for (let x = 1; x < grid.dimX() - 1; x++) {
        const cell = grid.get(x, y);

        if (
          cell.distanceToObstacle > distanceMin &&
          cell.regionID === RasterizationCell.NULL_REGION_ID
        ) {
          // Not a border or obstacle region cell. Should be in a region.
          floodedCells.push(cell);
        }
      }
    }

    // Perform a final expansion of existing regions.
    // Allow more iterations than normal for this last expansion.
    if (distanceMin > 0) {
      this.expandRegions(grid, floodedCells, expandIterations * 8);
    } else {
      this.expandRegions(grid, floodedCells, -1);
    }

    grid.regionCount = nextRegionID;

    this.obstacleRegionBordersCleaner.fixObstacleRegion(grid);
    //TODO Also port FilterOutSmallRegions?
    // The algorithm to remove vertices in the middle (added at the end of
    // ContourBuilder.buildContours) may already filter them and contour are
    // faster to process than cells.
  }

  /**
   * Attempts to find the most appropriate regions to attach cells to.
   *
   * Any cells successfully attached to a region will have their list
   * entry set to null. So any non-null entries in the list will be cells
   * for which a region could not be determined.
   *
   * @param grid
   * @param inoutCells As input, the list of cells available for formation
   * of new regions. As output, the cells that could not be assigned
   * to new regions.
   * @param maxIterations If set to -1, will iterate through completion.
   */
  private expandRegions(
    grid: RasterizationGrid,
    inoutCells: Array<RasterizationCell | null>,
    iterationMax: integer
  ) {
    if (inoutCells.length === 0) return;
    let skipped = 0;
    for (
      let iteration = 0;
      (iteration < iterationMax || iterationMax === -1) &&
      // All cells have either been processed or could not be
      // processed during the last cycle.
      skipped < inoutCells.length;
      iteration++
    ) {
      // The number of cells in the working list that have been
      // successfully processed or could not be processed successfully
      // for some reason.
      // This value controls when iteration ends.
      skipped = 0;

      for (let index = 0; index < inoutCells.length; index++) {
        const cell = inoutCells[index];
        if (cell === null) {
          // The cell originally at this index location has
          // already been successfully assigned a region. Nothing
          // else to do with it.
          skipped++;
          continue;
        }
        // Default to unassigned.
        let cellRegion = RasterizationCell.NULL_REGION_ID;
        let regionCenterDist = Number.MAX_VALUE;
        for (const delta of RasterizationGrid.neighbor4Deltas) {
          const neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);
          if (neighbor.regionID !== RasterizationCell.NULL_REGION_ID) {
            if (neighbor.distanceToRegionCore + 2 < regionCenterDist) {
              // This neighbor is closer to its region core
              // than previously detected neighbors.

              // Conservative expansion constraint:
              // Check to ensure that this neighbor has
              // at least two other neighbors in its region.
              // This makes sure that adding this cell to
              // this neighbor's  region will not result
              // in a single width line of cells.
              let sameRegionCount = 0;
              for (
                let neighborDirection = 0;
                neighborDirection < 4;
                neighborDirection++
              ) {
                const nnCell = grid.getNeighbor(neighbor, neighborDirection);
                // There is a diagonal-neighbor
                if (nnCell.regionID === neighbor.regionID) {
                  // This neighbor has a neighbor in
                  // the same region.
                  sameRegionCount++;
                }
              }
              if (sameRegionCount > 1) {
                cellRegion = neighbor.regionID;
                regionCenterDist = neighbor.distanceToRegionCore + 2;
              }
            }
          }
        }
        if (cellRegion !== RasterizationCell.NULL_REGION_ID) {
          // Found a suitable region for this cell to belong to.
          // Mark this index as having been processed.
          inoutCells[index] = null;
          cell.regionID = cellRegion;
          cell.distanceToRegionCore = regionCenterDist;
        } else {
          // Could not find an existing region for this cell.
          skipped++;
        }
      }
    }
  }

  /**
   * Creates a new region surrounding a cell, adding neighbor cells to the
   * new region as appropriate.
   *
   * The new region creation will fail if the root cell is on the
   * border of an existing region.
   *
   * All cells added to the new region as part of this process become
   * "core" cells with a distance to region core of zero.
   *
   * @param grid
   * @param rootCell The cell used to seed the new region.
   * @param fillToDist The watershed distance to flood to.
   * @param regionID The region ID to use for the new region
   * (if creation is successful).
   * @return true if a new region was created.
   */
  private floodNewRegion(
    grid: RasterizationGrid,
    rootCell: RasterizationCell,
    fillToDist: integer,
    regionID: integer
  ) {
    const workingStack = this.workingStack;
    workingStack.length = 0;
    workingStack.push(rootCell);
    rootCell.regionID = regionID;
    rootCell.distanceToRegionCore = 0;

    let regionSize = 0;
    let cell: RasterizationCell | undefined;
    while ((cell = workingStack.pop())) {
      // Check regions of neighbor cells.
      //
      // If any neighbor is found to have a region assigned, then
      // the current cell can't be in the new region
      // (want standard flooding algorithm to handle deciding which
      // region this cell should go in).
      //
      // Up to 8 neighbors are checked.
      //
      // Neighbor searches:
      // http://www.critterai.org/projects/nmgen_study/heightfields.html#nsearch
      let isOnRegionBorder = false;
      for (const delta of RasterizationGrid.neighbor8Deltas) {
        const neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);
        isOnRegionBorder =
          neighbor.regionID !== RasterizationCell.NULL_REGION_ID &&
          neighbor.regionID !== regionID;
        if (isOnRegionBorder) break;
      }
      if (isOnRegionBorder) {
        cell.regionID = RasterizationCell.NULL_REGION_ID;
        continue;
      }
      regionSize++;

      // If got this far, we know the current cell is part of the new
      // region. Now check its neighbors to see if they should be
      // assigned to this new region.
      for (const delta of RasterizationGrid.neighbor4Deltas) {
        const neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);

        if (
          neighbor.distanceToObstacle >= fillToDist &&
          neighbor.regionID === RasterizationCell.NULL_REGION_ID
        ) {
          neighbor.regionID = regionID;
          neighbor.distanceToRegionCore = 0;
          workingStack.push(neighbor);
        }
      }
    }
    return regionSize > 0;
  }

  private static firstPassDeltas = [
    { x: -1, y: 0, distance: 2 },
    { x: -1, y: -1, distance: 3 },
    { x: 0, y: -1, distance: 2 },
    { x: 1, y: -1, distance: 3 },
  ];
  private static secondPassDeltas = [
    { x: 1, y: 0, distance: 2 },
    { x: 1, y: 1, distance: 3 },
    { x: 0, y: 1, distance: 2 },
    { x: -1, y: 1, distance: 3 },
  ];

  /**
   * Generates distance field information.
   * The {@link RasterizationCell.distanceToObstacle} information is generated
   * for all cells in the field.
   *
   * All distance values are relative and do not represent explicit
   * distance values (such as grid unit distance). The algorithm which is
   * used results in an approximation only. It is not exhaustive.
   *
   * The data generated by this operation is required by
   * {@link RegionGenerator.generateRegions}.
   *
   * @param grid A field with cells obstacle information already generated.
   */
  generateDistanceField(grid: RasterizationGrid) {
    // close borders
    for (let x = 0; x < grid.dimX(); x++) {
      const leftCell = grid.get(x, 0);
      leftCell.distanceToObstacle = 0;
      const rightCell = grid.get(x, grid.dimY() - 1);
      rightCell.distanceToObstacle = 0;
    }
    for (let y = 1; y < grid.dimY() - 1; y++) {
      const topCell = grid.get(0, y);
      topCell.distanceToObstacle = 0;
      const bottomCell = grid.get(grid.dimX() - 1, y);
      bottomCell.distanceToObstacle = 0;
    }
    // The next two phases basically check the neighbors of a cell and
    // set the cell's distance field to be slightly greater than the
    // neighbor with the lowest border distance. Distance is increased
    // slightly more for diagonal-neighbors than for axis-neighbors.

    // 1st pass
    // During this pass, the following neighbors are checked:
    // (-1, 0) (-1, -1) (0, -1) (1, -1)
    for (let y = 1; y < grid.dimY() - 1; y++) {
      for (let x = 1; x < grid.dimX() - 1; x++) {
        const cell = grid.get(x, y);
        for (const delta of RegionGenerator.firstPassDeltas) {
          const distanceByNeighbor =
            grid.get(x + delta.x, y + delta.y).distanceToObstacle +
            delta.distance;
          if (cell.distanceToObstacle > distanceByNeighbor) {
            cell.distanceToObstacle = distanceByNeighbor;
          }
        }
      }
    }
    // 2nd pass
    // During this pass, the following neighbors are checked:
    //   (1, 0) (1, 1) (0, 1) (-1, 1)
    //
    // Besides checking different neighbors, this pass performs its
    // grid search in reverse order.
    for (let y = grid.dimY() - 2; y >= 1; y--) {
      for (let x = grid.dimX() - 2; x >= 1; x--) {
        const cell = grid.get(x, y);
        for (const delta of RegionGenerator.secondPassDeltas) {
          const distanceByNeighbor =
            grid.get(x + delta.x, y + delta.y).distanceToObstacle +
            delta.distance;
          if (cell.distanceToObstacle > distanceByNeighbor) {
            cell.distanceToObstacle = distanceByNeighbor;
          }
        }
      }
    }
  }
}

/**
 * Implements three algorithms that clean up issues that can
 * develop around obstacle region boarders.
 *
 * - Detect and fix encompassed obstacle regions:
 *
 * If a obstacle region is found that is fully encompassed by a single
 * region, then the region will be split into two regions at the
 * obstacle region border.
 *
 * - Detect and fix "short wrapping" of obstacle regions:
 *
 * Regions can sometimes wrap slightly around the corner of a obstacle region
 * in a manner that eventually results in the formation of self-intersecting
 * polygons.
 *
 * Example: Before the algorithm is applied:
 * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_08_cornerwrapbefore.jpg"
 *
 * Example: After the algorithm is applied:
 * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_09_cornerwrapafter.jpg
 *
 * - Detect and fix incomplete obstacle region connections:
 *
 * If a region touches obstacle region only diagonally, then contour detection
 * algorithms may not properly detect the obstacle region connection. This can
 * adversely effect other algorithms in the pipeline.
 *
 * Example: Before algorithm is applied:
 *
 *     b b a a a a
 *     b b a a a a
 *     a a x x x x
 *     a a x x x x
 *
 * Example: After algorithm is applied:
 *
 *     b b a a a a
 *     b b b a a a <-- Cell transferred to region B.
 *     a a x x x x
 *     a a x x x x
 *
 *
 * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html
 */
class ObstacleRegionBordersCleaner {
  private workingUpLeftOpenCells: RasterizationCell[];
  private workingDownRightOpenCells: RasterizationCell[];
  private workingOpenCells: RasterizationCell[];

  constructor() {
    this.workingUpLeftOpenCells = new Array<RasterizationCell>(512);
    this.workingDownRightOpenCells = new Array<RasterizationCell>(512);
    this.workingOpenCells = new Array<RasterizationCell>(512);
  }

  /**
   * This operation utilizes {@link RasterizationCell.contourFlags}. It
   * expects the value to be zero on entry, and re-zero's the value
   * on exit.
   *
   * @param grid a grid with fully built regions.
   */
  public fixObstacleRegion(grid: RasterizationGrid) {
    const workingUpLeftOpenCells = this.workingUpLeftOpenCells;
    workingUpLeftOpenCells.length = 0;
    const workingDownRightOpenCells = this.workingDownRightOpenCells;
    workingDownRightOpenCells.length = 0;
    const workingOpenCells = this.workingOpenCells;
    workingOpenCells.length = 0;
    const extremeCells: [RasterizationCell | null, RasterizationCell | null] = [
      null,
      null,
    ];

    let nextRegionID = grid.regionCount;

    // Iterate over the cells, trying to find obstacle region borders.
    for (let y = 1; y < grid.dimY() - 1; y++) {
      for (let x = 1; x < grid.dimX() - 1; x++) {
        const cell = grid.get(x, y);

        if (cell.contourFlags !== 0)
          // Cell was processed in a previous iteration.
          // Ignore it.
          continue;

        cell.contourFlags = 1;

        let workingCell: RasterizationCell | null = null;
        let edgeDirection = -1;

        if (cell.regionID !== RasterizationCell.OBSTACLE_REGION_ID) {
          // Not interested in this cell.
          continue;
        }
        // This is a obstacle region cell. See if it
        // connects to a cell in a non-obstacle region.
        edgeDirection = this.getNonNullBorderDirection(grid, cell);
        if (edgeDirection === -1)
          // This cell is not a border cell. Ignore it.
          continue;

        // This is a border cell. Step into the non-null
        // region and swing the direction around 180 degrees.
        workingCell = grid.getNeighbor(cell, edgeDirection);
        edgeDirection = (edgeDirection + 2) & 0x3;

        // Process the obstacle region contour. Detect and fix
        // local issues. Determine if the region is
        // fully encompassed by a single non-obstacle region.
        const isEncompassedNullRegion = this.processNullRegion(
          grid,
          workingCell,
          edgeDirection,
          extremeCells
        );

        if (isEncompassedNullRegion) {
          // This cell is part of a group of obstacle region cells
          // that is encompassed within a single non-obstacle region.
          // This is not permitted. Need to fix it.
          this.partialFloodRegion(
            grid,
            extremeCells[0]!,
            extremeCells[1]!,
            nextRegionID
          );
          nextRegionID++;
        }
      }
    }

    grid.regionCount = nextRegionID;

    // Clear all flags.
    for (let y = 1; y < grid.dimY() - 1; y++) {
      for (let x = 1; x < grid.dimX() - 1; x++) {
        const cell = grid.get(x, y);
        cell.contourFlags = 0;
      }
    }
  }

  /**
   * Partially flood a region away from the specified direction.
   *
   * {@link RasterizationCell.contourFlags}
   * is set to zero for all flooded cells.
   *
   * @param grid
   * @param startCell The cell to start the flood from.
   * @param borderDirection  The hard border for flooding. No
   * cells in this direction from the startCell will be flooded.
   * @param newRegionID The region id to assign the flooded
   * cells to.
   */
  private partialFloodRegion(
    grid: RasterizationGrid,
    upLeftCell: RasterizationCell,
    downRightCell: RasterizationCell,
    newRegionID: integer
  ): void {
    let upLeftOpenCells = this.workingUpLeftOpenCells;
    let downRightOpenCells = this.workingDownRightOpenCells;
    let workingOpenCells = this.workingOpenCells;
    // The implementation differs from CritterAI to avoid non-contiguous
    // sections. Instead of brushing in one direction, it floods from
    // 2 extremities of the encompassed obstacle region.

    const regionID = upLeftCell.regionID;

    if (regionID === newRegionID) {
      // avoid infinity loop
      console.error("Can't create a new region with an ID that already exist.");
      return;
    }

    // The 1st flooding set a new the regionID
    upLeftCell.regionID = newRegionID;
    upLeftCell.distanceToRegionCore = 0; // This information is lost.
    upLeftOpenCells.length = 0;
    upLeftOpenCells.push(upLeftCell);

    // The 2nd flooding keep the regionID and mark the cell as visited.
    downRightCell.contourFlags = 2;
    downRightCell.distanceToRegionCore = 0; // This information is lost.
    downRightOpenCells.length = 0;
    downRightOpenCells.push(downRightCell);

    let swap: RasterizationCell[];
    workingOpenCells.length = 0;

    while (upLeftOpenCells.length !== 0 || downRightOpenCells.length !== 0) {
      for (const cell of upLeftOpenCells) {
        for (let direction = 0; direction < 4; direction++) {
          const neighbor = grid.getNeighbor(cell, direction);
          if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {
            continue;
          }

          // Transfer the neighbor to the new region.
          neighbor.regionID = newRegionID;
          neighbor.distanceToRegionCore = 0; // This information is lost.

          workingOpenCells.push(neighbor);
        }
      }

      // This allows to flood the nearest cells first without needing lifo queue.
      // But a queue would take less memory.
      swap = upLeftOpenCells;
      upLeftOpenCells = workingOpenCells;
      workingOpenCells = swap;
      workingOpenCells.length = 0;

      for (const cell of downRightOpenCells) {
        for (let direction = 0; direction < 4; direction++) {
          const neighbor = grid.getNeighbor(cell, direction);
          if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {
            continue;
          }

          // Keep the neighbor to the current region.
          neighbor.contourFlags = 2;
          neighbor.distanceToRegionCore = 0; // This information is lost.

          workingOpenCells.push(neighbor);
        }
      }

      swap = downRightOpenCells;
      downRightOpenCells = workingOpenCells;
      workingOpenCells = swap;
      workingOpenCells.length = 0;
    }
  }

  /**
   * Detects and fixes bad cell configurations in the vicinity of a
   * obstacle region contour (See class description for details).
   * @param grid
   * @param startCell A cell in a non-obstacle region that borders a null
   * region.
   * @param startDirection The direction of the obstacle region border.
   * @return TRUE if the start cell's region completely encompasses
   * the obstacle region.
   */
  private processNullRegion(
    grid: RasterizationGrid,
    startCell: RasterizationCell,
    startDirection: integer,
    extremeCells: [RasterizationCell | null, RasterizationCell | null]
  ): boolean {
    // This algorithm traverses the contour. As it does so, it detects
    // and fixes various known dangerous cell configurations.
    //
    // Traversing the contour:  A good way to  visualize it is to think
    // of a robot sitting on the floor facing  a known wall. It then
    // does the following to skirt the wall:
    // 1. If there is a wall in front of it, turn clockwise in 90 degrees
    //    increments until it finds the wall is gone.
    // 2. Move forward one step.
    // 3. Turn counter-clockwise by 90 degrees.
    // 4. Repeat from step 1 until it finds itself at its original
    //    location facing its original direction.
    //
    // See also: http://www.critterai.org/projects/nmgen_study/regiongen.html#robotwalk
    //
    // As the traversal occurs, the number of acute (90 degree) and
    // obtuse (270 degree) corners are monitored. If a complete contour is
    // detected and (obtuse corners > acute corners), then the null
    // region is inside the contour. Otherwise the obstacle region is
    // outside the contour, which we don't care about.

    const borderRegionID = startCell.regionID;

    // Prepare for loop.
    let cell = startCell;
    let neighbor: RasterizationCell | null = null;
    let direction = startDirection;

    let upLeftCell = cell;
    let downRightCell = cell;

    // Initialize monitoring variables.
    let loopCount = 0;
    let acuteCornerCount = 0;
    let obtuseCornerCount = 0;
    let stepsWithoutBorder = 0;
    let borderSeenLastLoop = false;
    let isBorder = true; // Initial value doesn't matter.

    // Assume a single region is connected to the obstacle region
    // until proven otherwise.
    let hasSingleConnection = true;

    // The loop limit exists for the sole reason of preventing
    // an infinite loop in case of bad input data.
    // It is set to a very high value because there is no way of
    // definitively determining a safe smaller value. Setting
    // the value too low can result in rescanning a contour
    // multiple times, killing performance.
    while (++loopCount < 1 << 30) {
      // Get the cell across the border.
      neighbor = grid.getNeighbor(cell, direction);

      // Detect which type of edge this direction points across.
      if (neighbor === null) {
        // It points across a obstacle region border edge.
        isBorder = true;
      } else {
        // We never need to perform contour detection
        // on this cell again. So mark it as processed.
        neighbor.contourFlags = 1;
        if (neighbor.regionID === RasterizationCell.OBSTACLE_REGION_ID) {
          // It points across a obstacle region border edge.
          isBorder = true;
        } else {
          // This isn't a obstacle region border.
          isBorder = false;
          if (neighbor.regionID !== borderRegionID)
            // It points across a border to a non-obstacle region.
            // This means the current contour can't
            // represent a fully encompassed obstacle region.
            hasSingleConnection = false;
        }
      }

      // Process the border.
      if (isBorder) {
        // It is a border edge.
        if (borderSeenLastLoop) {
          // A border was detected during the last loop as well.
          // Two detections in a row indicates we passed an acute
          // (inner) corner.
          //
          //     a x
          //     x x
          acuteCornerCount++;
        } else if (stepsWithoutBorder > 1) {
          // We have moved at least two cells before detecting
          // a border. This indicates we passed an obtuse
          // (outer) corner.
          //
          //     a a
          //     a x
          obtuseCornerCount++;
          stepsWithoutBorder = 0;
          // Detect and fix cell configuration issue around this
          // corner.
          if (this.processOuterCorner(grid, cell, direction))
            // A change was made and it resulted in the
            // corner area having multiple region connections.
            hasSingleConnection = false;
        }
        direction = (direction + 1) & 0x3; // Rotate in clockwise direction.
        borderSeenLastLoop = true;
        stepsWithoutBorder = 0;
      } else {
        // Not a obstacle region border.
        // Move to the neighbor and swing the search direction back
        // one increment (counterclockwise). By moving the direction
        // back one increment we guarantee we don't miss any edges.
        cell = neighbor;
        direction = (direction + 3) & 0x3; // Rotate counterclockwise direction.
        borderSeenLastLoop = false;
        stepsWithoutBorder++;

        if (
          cell.x < upLeftCell.x ||
          (cell.x === upLeftCell.x && cell.y < upLeftCell.y)
        ) {
          upLeftCell = cell;
        }
        if (
          cell.x > downRightCell.x ||
          (cell.x === downRightCell.x && cell.y > downRightCell.y)
        ) {
          downRightCell = cell;
        }
      }

      if (startCell === cell && startDirection === direction) {
        extremeCells[0] = upLeftCell;
        extremeCells[1] = downRightCell;
        // Have returned to the original cell and direction.
        // The search is complete.
        // Is the obstacle region inside the contour?
        return hasSingleConnection && obtuseCornerCount > acuteCornerCount;
      }
    }

    // If got here then the obstacle region boarder is too large to be fully
    // explored. So it can't be encompassed.
    return false;
  }

  /**
   * Detects and fixes cell configuration issues in the vicinity
   * of obtuse (outer) obstacle region corners.
   * @param grid
   * @param referenceCell The cell in a non-obstacle region that is
   * just past the outer corner.
   * @param borderDirection The direction of the obstacle region border.
   * @return TRUE if more than one region connects to the obstacle region
   * in the vicinity of the corner (this may or may not be due to
   * a change made by this operation).
   */
  private processOuterCorner(
    grid: RasterizationGrid,
    referenceCell: RasterizationCell,
    borderDirection: integer
  ): boolean {
    let hasMultiRegions = false;

    // Get the previous two cells along the border.
    let backOne = grid.getNeighbor(referenceCell, (borderDirection + 3) & 0x3);
    let backTwo = grid.getNeighbor(backOne, borderDirection);
    let testCell: RasterizationCell;

    if (
      backOne.regionID !== referenceCell.regionID &&
      // This differ from the CritterAI implementation.
      // To filter vertices in the middle, this must be avoided too:
      //     a x
      //     b c
      backTwo.regionID !== backOne.regionID
    ) {
      // Dangerous corner configuration.
      //
      //     a x
      //     b a
      //
      // Need to change to one of the following configurations:
      //
      //     b x        a x
      //     b a        b b
      //
      // Reason: During contour detection this type of configuration can
      // result in the region connection being detected as a
      // region-region portal, when it is not. The region connection
      // is actually interrupted by the obstacle region.
      //
      // This configuration has been demonstrated to result in
      // two regions being improperly merged to encompass an
      // internal obstacle region.
      //
      // Example:
      //
      //     a a x x x a
      //     a a x x a a
      //     b b a a a a
      //     b b a a a a
      //
      // During contour and connection detection for region b, at no
      // point will the obstacle region be detected. It will appear
      // as if a clean a-b portal exists.
      //
      // An investigation into fixing this issue via updates to the
      // watershed or contour detection algorithms did not turn
      // up a better way of resolving this issue.
      hasMultiRegions = true;
      // Determine how many connections backTwo has to backOne's region.
      testCell = grid.getNeighbor(backOne, (borderDirection + 3) & 0x3);
      let backTwoConnections = 0;
      if (testCell.regionID === backOne.regionID) {
        backTwoConnections++;
        testCell = grid.getNeighbor(testCell, borderDirection);
        if (testCell.regionID === backOne.regionID) backTwoConnections++;
      }
      // Determine how many connections the reference cell has
      // to backOne's region.
      let referenceConnections = 0;
      testCell = grid.getNeighbor(backOne, (borderDirection + 2) & 0x3);
      if (testCell.regionID === backOne.regionID) {
        referenceConnections++;
        testCell = grid.getNeighbor(testCell, (borderDirection + 2) & 0x3);
        if (testCell.regionID === backOne.regionID) backTwoConnections++;
      }
      // Change the region of the cell that has the most connections
      // to the target region.
      if (referenceConnections > backTwoConnections)
        referenceCell.regionID = backOne.regionID;
      else backTwo.regionID = backOne.regionID;
    } else if (
      backOne.regionID === referenceCell.regionID &&
      backTwo.regionID === referenceCell.regionID
    ) {
      // Potential dangerous short wrap.
      //
      //  a x
      //  a a
      //
      //  Example of actual problem configuration:
      //
      //  b b x x
      //  b a x x <- Short wrap.
      //  b a a a
      //
      //  In the above case, the short wrap around the corner of the
      //  obstacle region has been demonstrated to cause self-intersecting
      //  polygons during polygon formation.
      //
      //  This algorithm detects whether or not one (and only one)
      //  of the axis neighbors of the corner should be re-assigned to
      //  a more appropriate region.
      //
      //  In the above example, the following configuration is more
      //  appropriate:
      //
      //  b b x x
      //  b b x x <- Change to this row.
      //  b a a a
      // Check to see if backTwo should be in a different region.
      let selectedRegion = this.selectedRegionID(
        grid,
        backTwo,
        (borderDirection + 1) & 0x3,
        (borderDirection + 2) & 0x3
      );
      if (selectedRegion === backTwo.regionID) {
        // backTwo should not be re-assigned. How about
        // the reference cell?
        selectedRegion = this.selectedRegionID(
          grid,
          referenceCell,
          borderDirection,
          (borderDirection + 3) & 0x3
        );
        if (selectedRegion !== referenceCell.regionID) {
          // The reference cell should be reassigned
          // to a new region.
          referenceCell.regionID = selectedRegion;
          hasMultiRegions = true;
        }
      } else {
        // backTwo should be re-assigned to a new region.
        backTwo.regionID = selectedRegion;
        hasMultiRegions = true;
      }
    } else hasMultiRegions = true;
    // No dangerous configurations detected. But definitely
    // has a change in regions at the corner. We know this
    // because one of the previous checks looked for a single
    // region for all wrap cells.
    return hasMultiRegions;
  }

  /**
   * Checks the cell to see if it should be reassigned to a new region.
   *
   * @param grid
   * @param referenceCell A cell on one side of an obstacle region contour's
   * outer corner. It is expected that the all cells that wrap the
   * corner are in the same region.
   * @param borderDirection  The direction of the obstacle region border.
   * @param cornerDirection The direction of the outer corner from the
   * reference cell.
   * @return The region the cell should be a member of. May be the
   * region the cell is currently a member of.
   */
  private selectedRegionID(
    grid: RasterizationGrid,
    referenceCell: RasterizationCell,
    borderDirection: integer,
    cornerDirection: integer
  ): integer {
    // Initial example state:
    //
    // a - Known region.
    // x - Null region.
    // u - Unknown, not checked yet.
    //
    //     u u u
    //     u a x
    //     u a a

    // The only possible alternate region id is from
    // the cell that is opposite the border. So check it first.
    let regionID = grid.getNeighbor(referenceCell, (borderDirection + 2) & 0x3)
      .regionID;
    if (
      regionID === referenceCell.regionID ||
      regionID === RasterizationCell.OBSTACLE_REGION_ID
    )
      // The region away from the border is either a obstacle region
      // or the same region. So we keep the current region.
      //
      //     u u u      u u u
      //     a a x  or  x a x  <-- Potentially bad, but stuck with it.
      //     u a a      u a a
      return referenceCell.regionID;

    // Candidate region for re-assignment.
    let potentialRegion = regionID;

    // Next we check the region opposite from the corner direction.
    // If it is the current region, then we definitely can't
    // change the region id without risk of splitting the region.
    regionID = grid.getNeighbor(referenceCell, (cornerDirection + 2) & 0x3)
      .regionID;
    if (
      regionID === referenceCell.regionID ||
      regionID === RasterizationCell.OBSTACLE_REGION_ID
    )
      // The region opposite from the corner direction is
      // either a obstacle region or the same region. So we
      // keep the current region.
      //
      //     u a u      u x u
      //     b a x  or  b a x
      //     u a a      u a a
      return referenceCell.regionID;

    // We have checked the early exit special cases. Now a generalized
    // brute count is performed.
    //
    // Priority is given to the potential region. Here is why:
    // (Highly unlikely worst case scenario)
    //
    //     c c c    c c c
    //     b a x -> b b x  Select b even though b count == a count.
    //     b a a    b a a

    // Neighbors in potential region.
    // We know this will have a minimum value of 1.
    let potentialCount = 0;

    // Neighbors in the cell's current region.
    // We know this will have a minimum value of 2.
    let currentCount = 0;

    // Maximum edge case:
    //
    //     b b b
    //     b a x
    //     b a a
    //
    // The maximum edge case for region A can't exist. It
    // is filtered out during one of the earlier special cases
    // handlers.
    //
    // Other cases may exist if more regions are involved.
    // Such cases will tend to favor the current region.

    for (let direction = 0; direction < 8; direction++) {
      let regionID = grid.getNeighbor(referenceCell, direction).regionID;
      if (regionID === referenceCell.regionID) currentCount++;
      else if (regionID === potentialRegion) potentialCount++;
    }

    return potentialCount < currentCount
      ? referenceCell.regionID
      : potentialRegion;
  }

  /**
   * Returns the direction of the first neighbor in a non-obstacle region.
   * @param grid
   * @param cell The cell to check.
   * @return The direction of the first neighbor in a non-obstacle region, or
   * -1 if all neighbors are in the obstacle region.
   */
  private getNonNullBorderDirection(
    grid: RasterizationGrid,
    cell: RasterizationCell
  ): integer {
    // Search axis-neighbors.
    for (
      let direction = 0;
      direction < RasterizationGrid.neighbor4Deltas.length;
      direction++
    ) {
      const delta = RasterizationGrid.neighbor4Deltas[direction];

      const neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);
      if (neighbor.regionID !== RasterizationCell.OBSTACLE_REGION_ID)
        // The neighbor is a obstacle region.
        return direction;
    }
    // All neighbors are in a non-obstacle region.
    return -1;
  }
}
